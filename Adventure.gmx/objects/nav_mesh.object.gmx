<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_pathfind</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Variables

globalvar path;
globalvar start_x;
globalvar start_y;
globalvar goal_x;
globalvar goal_y;
globalvar show_nav_mesh;
globalvar path_update;

open_list = ds_priority_create();
closed_list = ds_list_create();

start_x = -100;
start_y = -100;
goal_x = -100;
goal_y = -100;

path_update = false;
show_nav_mesh = false;
perm_nodes = ds_list_create();
perm_count = 1;
perm[0,0] = 0;
nodes[0,1] = 0;
path = path_add();
path_set_closed(path, false);
tt=0;
no = 1;



</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Generate Initial Mesh

with (wall) add_points_sqr(id, 18);

count = array_height_2d(perm);
for (i=1; i&lt;count; i++) //check each permenant polygon for over lap; i= the polygon number
   {
   pts = perm[i,0];
   for (j=1; j&lt;pts; j+=2) //check each node in the polygon; j = the point on the polygon being checked
      {
      inside = false;
      for (k=1; k&lt;count; k++) if (i != k) //check to see if the node is inside any of the other polygons
         {
         if (perm[k,0] = 8) inside = point_in_rectangle(perm[i,j], perm[i,j+1], perm[k,1], perm[k,2], perm[k,5], perm[k,6])
         // else do triangle checks to cover the polygons

         if (inside = true) k += count  //end test loop for that point 
         }
      if (inside = false) 
         {
         n = array_height_2d(nodes);
         nodes [n,0] = perm[i,j]
         nodes [n,1] = perm[i,j+1]
         }
      }
   }

count_node = array_height_2d(nodes); 
for (i=1; i&lt;count_node; i++) //determine each nodes neighbors
   {
   nbrs = 0;
   for (j=1; j&lt;count_node; j++)
      {
      if (node_los(nodes[i,0], nodes[i,1], nodes[j,0], nodes[j,1]))
         {
         nbrs++;
         nodes[i,3+nbrs] = j;
         }
      }
   nodes[i,3] = nbrs;
   }
   
with (player_u) pathing_start(id);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Path Find

if (path_update){

path_update = false;
//open_list = ds_priority_create();
//closed_list = ds_list_create();
count_node = array_height_2d(nodes);
path_found = 0;
if (!node_los(start_x, start_y, goal_x, goal_y)) { //see if start point can make it to end point with no path

for (i=0; i&lt;array_length_1d(selected.nav_array); i++) 
//add to open list all nodes start point has los to from the stored array in that character
   {
   var point = selected.nav_array[i];
   dist = point_distance(start_x, start_y, nodes[point,0], nodes[point,1])
   guess = point_distance(nodes[point,0], nodes[point,1], goal_x, goal_y)
   ds_priority_add(open_list, point, dist+guess);
   nodes[point,2] = 0;
   }
   
//show_debug_message("--Start--");
while (path_found = 0 &amp;&amp; !ds_priority_empty(open_list)) //cycle through open list until path to end point is found
   {
   next = ds_priority_find_min(open_list); //next = node being checked
   //show_debug_message("Low Node: " + string(next) + "  Priority: " + string(ds_priority_find_priority(open_list, next)));
   if (node_los(nodes[next,0], nodes[next,1], goal_x, goal_y)) //see if node has los to end point
      {
      path_found = next;
      }
   else //if no los to end point at priority to this nodes neighbors
      {   
       ds_list_add(closed_list, next);
       path_len = ds_priority_find_priority(open_list, next);
       //if (!is_undefined(path_len))
       path_len -= point_distance(nodes[next,0], nodes[next,1], goal_x, goal_y); //remove guess dist
       ds_priority_delete_min(open_list);
       nhbrs = nodes[next,3]  //number of neighbors the node has
       for (i=0; i&lt;nhbrs; i++)
          {
          nn = nodes[next,4+i]; //nn = nieghbor node
          dist = point_distance(nodes[nn,0], nodes[nn,1], nodes[next,0], nodes[next,1]); //dist from current node to this one
          guess = point_distance(nodes[nn,0], nodes[nn,1], goal_x, goal_y); //guess dist to end point
          if (ds_list_find_index(closed_list, nn) = -1) //make sure not on closed list
             {
             pri = ds_priority_find_priority(open_list, nn)
             if (is_undefined(pri))//if not already on open list
                {
                ds_priority_add(open_list, nn, path_len + dist + guess)//if not add to open list
                nodes[nn,2] = next; //have node point back to point checking for path forming
                }
             else   //if so compare current priority
                {
                pri -= guess;   
                if (path_len + dist &lt; pri) //if path via this node is shorter, update open list info
                   {
                   ds_priority_change_priority(open_list, nn, path_len + dist + guess);
                   nodes[nn,2] = next;
                   }
                }
             }
          }      
      }
   if (ds_priority_empty(open_list)) path_found = -1; //end loop if all nodes checked and no path found
   }
}

path_clear_points(path);
path_add_point(path, goal_x, goal_y, 100);

while (path_found &gt; 0)
   {
   path_insert_point(path, 0, nodes[path_found,0], nodes[path_found,1], 100)
   path_found = nodes[path_found, 2];
   }
if (path_found = 0) path_insert_point(path, 0, start_x, start_y, 100);

//ds_priority_destroy(open_list);
//ds_list_destroy(closed_list);
while (!ds_priority_empty(open_list)) ds_priority_delete_min(open_list);
while (!ds_list_empty(closed_list)) ds_list_delete(closed_list, 0);
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Nav Mesh

/*
if (show_nav_mesh){
siz = array_height_2d(nodes);

draw_set_colour(c_teal);
draw_circle(start_x, start_y, 5, false);
draw_circle(goal_x, goal_y, 5, false);

//Draw Nodes   
for(i=1; i&lt;siz; i++)
   {
   draw_set_color(c_green);
   draw_circle(nodes[i,0], nodes[i,1], 3, false);
   draw_set_color(c_green);
   if (ds_exists(open_list, ds_type_priority)) draw_text(nodes[i,0], nodes[i,1], string(ds_priority_find_priority(open_list, i)));
   draw_text(nodes[i,0], nodes[i,1]-10, string(i));
   draw_set_color(c_yellow);
   //if (node_los(startx, starty, nodes[i,0], nodes[i,1])) draw_line(startx, starty, nodes[i,0], nodes[i,1]);
   }



draw_set_color(c_maroon);      
var count = array_height_2d(perm);

//Draw Polygons connected
for (i=1; i&lt;count; i++)
   {
   var nnum = perm[i,0];
   for (j=1; j&lt;nnum; j+=2)
       {
       var px1 = perm[i,j];
       var px2 = perm[i,j+1];
       var t = j+2;
       if (j = nnum-1 || j = nnum) t = 1; //if last point in polygon it connects to first point in polygon
       var px3 = perm[i,t];
       var px4 = perm[i,t+1]
       draw_line(px1, px2, px3, px4);
       }
   } 

   
//Draw node nieghbor connections
/*
draw_set_color(c_olive);
tt++
if (tt=90) 
   {
   tt=0;
   no++;
   if (no = siz) no = 1;
   }

nbrs = nodes[no,3];
      
for (i=0; i&lt;nbrs; i++)
    {
    //if (node_los(nodes[no,0], nodes[no,1], nodes[i,0], nodes[i,1])) draw_line(nodes[no,0], nodes[no,1], nodes[i,0], nodes[i,1])
    nb = nodes[no,4+i]
    draw_line(nodes[no,0], nodes[no,1], nodes[nb,0], nodes[nb,1]);
    }   

}  
    
//if(ds_exists(open_list, ds_type_priority)) ds_priority_destroy(open_list);
while (ds_list_empty(open_list)) ds_list_delete(open_list, 0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>50,50</point>
  </PhysicsShapePoints>
</object>
